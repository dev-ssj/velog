<h1 id="💡-배열-vs-연결리스트-기본-차이">💡 배열 VS 연결리스트 기본 차이</h1>
<table>
<thead>
<tr>
<th>구분</th>
<th>배열(Array)</th>
<th>연결리스트(Linked List)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>메모리 구조</strong></td>
<td>연속된 메모리 공간에 저장</td>
<td>각 노드가 데이터 + 다음 노드의 포인터를 가짐</td>
</tr>
<tr>
<td><strong>랜덤 접근(Random Access)</strong></td>
<td>가능 (O(1)) → 인덱스로 바로 접근</td>
<td>불가능 (O(n)) → 처음부터 순차 탐색</td>
</tr>
<tr>
<td><strong>삽입/삭제</strong></td>
<td>중간에 삽입/삭제 시 뒤 원소들을 이동해야 함 → O(n)</td>
<td>포인터 변경만 하면 됨 (노드만 수정) → O(1) (단, 위치 탐색이 O(n))</td>
</tr>
<tr>
<td><strong>캐시 친화성</strong></td>
<td>메모리가 연속적이라 CPU 캐시 효율 높음</td>
<td>포인터 기반이라 캐시 효율 낮음</td>
</tr>
<tr>
<td><strong>메모리 오버헤드</strong></td>
<td>데이터만 저장 → 효율적</td>
<td>포인터(주소) 추가 저장 → 메모리 낭비 가능</td>
</tr>
</tbody></table>
<hr />
<h1 id="💡접근삽입삭제-속도-및-성능-비교">💡접근/삽입/삭제 속도 및 성능 비교</h1>
<h2 id="✅1-접근-속도읽기">✅1. 접근 속도(읽기)</h2>
<h3 id="🔸배열">🔸배열</h3>
<ul>
<li>arr[5]처럼 인덱스로 바로 접근 가능 → 주소 계산으로 <strong>O(1)</strong><h3 id="🔸연결-리스트">🔸연결 리스트</h3>
</li>
<li>5번째 원소를 찾으려면 처음(head)부터 차례대로 따라가야함 → <strong>O(n)</strong><br />

</li>
</ul>
<h2 id="✅2-삽입삭제">✅2. 삽입/삭제</h2>
<h3 id="🔸배열-1">🔸배열</h3>
<ul>
<li>맨 뒤에 추가 : O(1) (단, 할당된 용량 초과시 재할당 필요)</li>
<li>중간 삽입/삭제 : O(n) 원소들을 한칸씩 밀거나 당겨야함<h3 id="🔸연결-리스트-1">🔸연결 리스트</h3>
</li>
<li>맨 앞 삽입/삭제 : O(1)</li>
<li>중간 삽입/삭제 : O(1) (포인터만 수정하면 된다!)
하지만 위치 탐색 O(n)이 필요하므로 결국 평균은 O(n)</li>
</ul>
<p><strong>➡️ 읽기 위주라면 배열, 삽입/삭제가 잦으면 연결리스트가 유리</strong></p>
<hr />
<h1 id="💡실제-백엔드-환경에서의-사용-예시">💡실제 백엔드 환경에서의 사용 예시</h1>
<h3 id="🔸배열-2">🔸배열</h3>
<ul>
<li>조회가 많은 경우(DB 조회 결과 리스트, 캐시된 사용자 목록)</li>
<li>고정 길이나 사이즈 예측이 가능한 경우</li>
<li>CPU 캐시 친화적이라 성능이 중요한 경우<h3 id="🔸연결-리스트-2">🔸연결 리스트</h3>
</li>
<li>삽입/삭제가 빈번한 큐, 스택 구현 시</li>
<li>큰 데이터에서 중간 원소가 자주 제거/삽입 되는 경우</li>
</ul>
<hr />
<h1 id="💡캐시-구현-시-차이">💡캐시 구현 시 차이</h1>
<h3 id="🔸배열-기반-캐시">🔸배열 기반 캐시</h3>
<ul>
<li>인덱스로 바로 접근 가능 → 조회 성능 뛰어남</li>
<li>중간 원소 제거 시 비효율적 (O(n))</li>
<li>예시 : LRU 캐시를 배열만으로 구현하면 비효율적</li>
</ul>
<h3 id="🔸연결-리스트-기반-캐시">🔸연결 리스트 기반 캐시</h3>
<ul>
<li>삽입/삭제 용이(노드 포인터만 조정하면 되므로)</li>
<li>자주 쓰이는 구조 : HashMap + Double Linked List<ul>
<li>HashMap으로 O(1) 조회<ul>
<li>LinkedList로 O(1) 삽입/삭제</li>
<li>실제 LRUCache, LRUCache 구현 방식이 이 패턴이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<p><strong>1. 배열과 연결리스트의 가장 큰 차이는?</strong>
➡️메모리 연속성과 랜덤 접근 가능 여부
배열은 연속된 공간이라 인덱스로 접근 가능하지만, 연결리스트는 포인터로 연결되어 있어 순차 탐색 해야한다.</p>
<p><strong>2. 배열은 왜 O(1) 접근이 가능하고, 연결리스트는 O(n)인가요?</strong>
배열은 시작주소와 크기가 결정되어 있어 바로 계산 가능하지만, 연결 리스트는 포인터를 따라가야하므로 선형 탐색이 필요합니다.</p>
<p><strong>3. 삽입/삭제 성능 비교는?</strong>
배열은 중간에서 삽입/삭제가 일어나게 되면 원소들의 이동이 필요하므로 O(n)이고, 연결리스트는 포인터만 수정하면 되므로 O(1)입니다. 단, 탐색은 선형탐색이므로 O(n)입니다.</p>
<p><strong>4. 실제 백엔드에서 배열과 연결리스트는 언제 쓰나요?</strong>
조회가 많은 경우엔 배열을, 삽입 삭제가 많으면 연결리스트를 사용합니다.</p>
<p><strong>5. 배열과 연결리스트로 캐시 구현시 어떤 차이가 있나요?</strong>
가장 오래 사용되지 않은 데이터를 제거하는 캐시 알고리즘인 LRU 캐시는 HashMap + LinkedList 조합으로 O(1) 조회/삽입/삭제 보장합니다. 하지만 단순 배열로 구현하게된다면 중간 삭제 때문에 성능 저하.</p>