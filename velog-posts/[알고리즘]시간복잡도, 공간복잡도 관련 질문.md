<p><strong>1. Big-O, Big-Theta, Big-Omega의 차이를 설명해보세요.</strong></p>
<ul>
<li><p>Big-O(상한)</p>
<ul>
<li>입력이 최악일 때 걸리는 시간의 상한</li>
<li>성능을 보수적으로 설명할 때 주로 사용</li>
<li>예 : 이진탐색</li>
</ul>
</li>
<li><p>Big-Theta(평균)</p>
<ul>
<li>상한과 하한이 동일할때, 평균적으로 걸리는 시간</li>
<li>예 : 퀵소트 평균 Θ(n log n)</li>
</ul>
<ul>
<li>Big-Omega(하한)<ul>
<li>입력이 최선일 때 걸리는 최소 시간</li>
<li>성능을 보수적으로 설명할 때 주로 사용</li>
<li>예 : 이진탐색</li>
<li>*</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>👉왜 빅오는 최악 기준으로 많이 쓰나요?**
→ 실무에서는 성능을 보장해야 하기 때문에 최악의 경우를 기준으로 설명하는 것이 안전합니다.</p>
<hr />
<p><strong>2. 복잡도의 예시를 들어보세요.</strong></p>
<ul>
<li>O(1): 배열 인덱스 접근, 해시맵 조회</li>
<li>O(log n): 이진 탐색, 균형 BST 탐색</li>
<li>O(n): 배열/리스트 순회, 최대/최소값 찾기</li>
<li>O(n log n): 병합 정렬, 힙 정렬, 퀵 정렬(평균)</li>
<li>O(n²): 버블/삽입/선택 정렬, 플로이드-워셜 알고리즘</li>
</ul>
<p>👉<strong>해시맵은 평균 O(1)인데 왜 최악은 O(n)인가요?</strong>
→ 해시맵 충돌이 모두 같은 버킷에 몰리면 연결리스트 탐색이 필요하기 때문입니다.
연결리스트 탐색은 복잡도가 O(n)이므로 해시맵의 최악은 O(n)입니다.</p>
<hr />
<p><strong>3. 재귀 vs 반복 (시간/공간 복잡도)</strong></p>
<ul>
<li>시간복잡도 : 반복문 팩토리얼과 재귀 팩토리얼 둘다 O(n)이므로 같습니다.</li>
<li>공간 복잡도 : 재귀는 호출할때마다 스택을 사용하여 O(n)이고, 반복문은 O(1)입니다.</li>
<li>실무 작용 : 입력 크기가 크다면 스택 오버플로우 방지를 위해 반복문을 사용하는것이 안전합니다.</li>
</ul>
<p><strong>👉재귀는 반복문보다 불리한데 왜 씁니까?</strong>
→ 코드 가독성, 분할 정복 알고리즘 구현 용이성때문에 사용합니다(DFS, 퀵소트, 병합정렬)</p>
<hr />
<p><strong>4. 정렬 알고리즘 중 평균적으로 O(n log n)을 보장하는 것은 어떤 것들이 있나
요?</strong></p>
<ul>
<li>병합 정렬, 힙정렬, 퀵 정렬, 팀소트가 있습니다.</li>
</ul>
<p><strong>👉 왜 퀵 정렬은 평균 O(n log n)인데 최악은 O(n²)인가요?</strong>
→ 분할이 불균형하게 일어나면 재귀 깊이가 n까지 가므로 O(n²)까지 가게됩니다.</p>
<hr />
<p><strong>5. 공간 복잡도 최적화를 위해 어떤 기법들을 사용할 수 있나요?</strong></p>
<ul>
<li>투포인터 : 배열에서 양쪽끝에서 움직이면서 문제를 해결하는 방식 -&gt; 중복 순회 제거, 메모리 절약</li>
<li>In-place 알고리즘 : 새로운 배열을 만들지 않고 원래 자료구조 안에서만 값 교환/처리 -&gt; 퀵 정렬, 제자리 뒤집기</li>
</ul>