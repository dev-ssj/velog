<h1 id="💡스택stack">💡스택(Stack)</h1>
<p><img alt="" src="https://velog.velcdn.com/images/dev_ssj/post/c99f27aa-12cf-4569-833a-7633a07b32df/image.png" /></p>
<ul>
<li>정의 : <strong>팬케이크를 먹는 것처럼 마지막에 올린 것을 가장 먹는 구조(LIFO)</strong></li>
<li>시간 복잡도 : 평균적으로 <strong>push, pop, peek 모두 O(1)</strong></li>
<li>연산<ul>
<li><code>push(x)</code> : 스택 맨 위(top)에 x 추가</li>
<li><code>pop()</code> : 맨 위 원소 제거 + 반환</li>
<li><code>peek()</code> : 맨 위 원소 조회(제거 하지 않음)</li>
</ul>
</li>
<li>사용 사례<ul>
<li><strong>재귀 호출 관리</strong> ( 함수 콜 스택)</li>
<li><strong>괄호 유효성 검사</strong><ul>
<li><strong>컴파일러/파서</strong> (중위 -&gt; 후위 변환)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h1 id="💡큐queue">💡큐(Queue)</h1>
<p><img alt="" src="https://velog.velcdn.com/images/dev_ssj/post/161cbf13-21f9-4a39-b943-b2c1a8c81ffe/image.png" /></p>
<ul>
<li><p>정의 :** 줄 서기 처럼 먼저 들어온 것이 먼저 나오는 구조(FIFO)**</p>
</li>
<li><p>시간 복잡도 : 평균적으로 <strong>offer/poll/peek 모두 O(1)</strong></p>
</li>
<li><p>연산</p>
<ul>
<li><code>enqueue(x)</code> 또는 <code>offer(x)</code> : 맨 뒤(tail)에 x 추가</li>
<li><code>dequeue()</code> 또는 <code>poll()</code> : 앞(front) 원소 제거 + 반환</li>
<li><code>peek()</code> : 맨 앞 원소 조회(제거 하지 않음)</li>
</ul>
</li>
<li><p>사용 사례</p>
<ul>
<li><strong>BFS 탐색</strong>(그래프/트리 최단 거리)</li>
<li><strong>작업 대기열(Job Queue), 메시지 큐(Kafka, RabbitMQ)</strong><ul>
<li><strong>운영체제 스케줄러</strong> (CPU 라운드로빈)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h1 id="💡변형된-큐">💡변형된 큐</h1>
<ul>
<li><p><strong>원형 큐(Circular Queue)</strong>
배열 기반에서 당기는 비용 제거 → head/tail 포인터를 순환시켜 공간 재사용.</p>
</li>
<li><p><strong>우선순위 큐(Priority Queue)</strong>
먼저 들어온 순서가 아니라 우선순위 값 기준. (Java: PriorityQueue)</p>
</li>
<li><p><strong>이중 큐(Deque)</strong>
앞/뒤 양쪽에서 삽입·삭제 가능. (Java: ArrayDeque)</p>
</li>
</ul>
<hr />
<p><strong>1. 스택과 큐의 차이를 설명해보세요.</strong>
스택은 LIFO, 큐는 FIFO 구조이며, 스택은 최근 작업을 우선처리하며 큐는 먼저 도착한 작업을 우선처리합니다. 각 연산의 복잡도는 평균 O(1)입니다.</p>
<p><strong>2. 스택의 대표 사례를 말해주세요</strong>
최근 작업을 되돌리거나 중첩 구조를 관리할때 사용되며, 대표사례로는 
함수 호출 스택(콜 스택), 문자열 역순, 괄호 검사/파서, 백트래킹, DFS</p>
<p><strong>3. 큐의 대표 사례를 말해주세요.</strong>
공평하게 순차적으로 처리해야할 때 사용되며, 대표 사례로는
BFS, 작업/메시지큐(비동기 처리)
<strong>👉BFS는 뭔가요?</strong>
그래프/트리 탐색 알고리즘 중 하나로, 시작 노드에서 가까운 노드부터 차례로 탐색하는 방식입니다. 탐색순서는 큐 덕분에 가까운 것부터 진행됩니다.</p>
<p><strong>4. 큐를 배열 OR 연결리스트로 구현했을 때의 차이점은 무엇인가요?</strong>
배열 : 캐시 친화, 상수 시간 빠르지만 크기 제한 있어 리사이즈가 필요합니다.
링크드리스트 : 유연한 크기, 하지만 메모리 오버헤드와 캐시 비우호적입니다.
대체로 배열 기반이 성능면에서 유리합니다.</p>
<p><strong>5. 원형 큐는 왜쓰나요?</strong>
단순 배열 큐는 dequeue 시 O(n)복사가 필요하지만, 원형 큐는 인덱스를 회전시켜 복잡도를 O(1)로 유지합니다.</p>
<p><strong>6. 스택/큐를 이용하여 괄호 검사문제는 어떻게 푸나요?</strong>
괄호 검사는 스택을 이용하는게 유리합니다.
위에서 부터 검사해서  여는 괄호를 만나면 push하고, 닫는 괄호를 만나면 top이 대응하는 괄호인지 확인 후, 짝을 만나면 pop, 전부 처리 후 스택이 비었으면 유효
시간복잡도, 공간복잡도 O(n)
<strong>👉왜 큐가 아니라 스택을 사용하나요?</strong>
닫는 괄호가 나오면 가장 최근에 열린 괄호와 매칭해야하므로 후입 선출 특성의 스택이 자연스럽습니다.</p>