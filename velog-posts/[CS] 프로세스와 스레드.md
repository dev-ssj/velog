<h1 id="💡프로세스와-스레드">💡프로세스와 스레드</h1>
<blockquote>
<p>프로세스와 스레드는 운영체제에서 프로그램이 실행될 때 사용되는 기본적인 단위이다.
웹 서버나 애플리케이션에서 동시에 여러 작업을 처리하려면 프로세스와 스레드에 대한 이해가 필요하다. 두 개념은 자원관리, 성능 최적화, 동시성 처리에 직접적인 영향을 주지만 관리와 자원사용 측면에서 차이점이 있다. 이 개념들을 이해하면 시스템에서 작업이 어떻게 실행되고 관리되는지 알 수 있다.</p>
</blockquote>
<hr />
<h1 id="💡프로세스process">💡프로세스(Process)</h1>
<h2 id="✅프로세스란">✅프로세스란?</h2>
<p><strong>실행 중인 프로그램</strong>을 의미하며, 프로그램이 실행되면 운영체제가 <strong>메모리, CPU시간, 자원 등을 할당</strong>하여 독립적으로 실행되는 단위이다. 각각의 프로세스는 <strong>고유의 메모리 공간</strong>(코드, 데이터, 힙, 스택)을 가지고 있다.</p>
<hr />
<h2 id="✅프로세스의-특징">✅프로세스의 특징</h2>
<ul>
<li><p><strong>독립적인 메모리 공간</strong> : 각 프로세스는 운영체제로부터 자신만의 고유한 메모리 공간(스택, 레지스터, 데이터 등)의 자원을 할당 받아 독립적으로 실행된다. 따라서 다른 프로세스와 메모리를 공유하지 않으며, 프로세스 간에는 서로의 데이터에 접근할 수 없다. 다른 프로세스와의 상호작용이 필요할 때는 프로세스 간 통신(IPC, Inter-Process Communication)을 사용해야한다. 프로세스 간 통신은 파이프, 소켓, 공유 메모리 등의 다양한 방법이 있다.</p>
</li>
<li><p><strong>자원관리</strong> : 프로세스는 운영체제로부터 실행에 필요한 시스템 자원(CPU, 메모리, 파일 디스크립터 등)을 할당받는다. 각 프로세스는 고유한 프로세스 ID(PID)를 통해 식별된다.</p>
</li>
<li><p><strong>무거움</strong> : 프로세스는 각각의 독립적인 자원을 가지므로 시스템 자원을 많이 사용하며 생성 및 종료에 시간이 오래걸리며, 문맥 교환 비용이 크다.</p>
</li>
</ul>
<hr />
<h2 id="✅프로세스의-자원-구조">✅프로세스의 자원 구조</h2>
<blockquote>
<p>하나의 프로세스는 <strong>독립적인 메모리 공간</strong>을 가지며, 크게 4가지 메모리 영역으로 나누어져 있다.</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/dev_ssj/post/b9fb1f45-42e3-496e-a60a-600ad5885e50/image.png" /></p>
<ul>
<li><strong>코드(Code)</strong> : 프로그램의 실행 코드(기계어)</li>
<li><strong>데이터(Data)</strong> : 전역 변수, 정적 변수 등</li>
<li><strong>힙(Heap)</strong> : 런타임 중 동적으로 생성되는 객체(예시:new 연산자)</li>
<li><strong>스택(Stack)</strong> : 함수 호출, 지역 변수, 매개 변수 등</li>
</ul>
<p>또한, 프로세스는 위 4가지 메모리 영역 외에도 <strong>여러 자원을 독립적으로 소유</strong>한다.</p>
<ul>
<li><strong>파일 디스크립터</strong> : 운영체제가 파일, 소켓, 파이프 등 I/O 자원을 식별하기 위해 부여하는 번호</li>
<li><strong>프로세스ID(PID)</strong> : 운영체제가 각 프로세스를 고유하게 식별하기 위해 부여하는 고유한 번호</li>
<li><strong>PCB(프로세스 제어 블록)</strong> : 운영체제가 프로세스의 상태, 메모리 정보, CPU 레지스터 등을 저장해 프로세스를 관리하는 데 사용하는 데이터 구조로, 커널 영역에 생성된다.</li>
</ul>
<blockquote>
<p><code>코드 영역</code>과 <code>데이터 영역</code>은 그 크기가 변하지 않아 <strong>정적 할당 영역</strong>이라고 부르며, <code>힙 영역</code>과 <code>스택 영역</code>은 프로세스 실행 과정에서 그 크기가 변할 수 있는 영역이라 <strong>동적 할당 영역</strong>이라고 부른다.</p>
</blockquote>
<hr />
<h2 id="✅프로세스의-예시">✅프로세스의 예시</h2>
<ul>
<li>크롬을 두 번 실행하면 각각의 창은 독립적인 프로세스</li>
<li>IDE, 메모장, 그림판 등은 각각 별도의 프로세스로 동작함</li>
</ul>
<hr />
<h2 id="✅프로세스의-상태">✅프로세스의 상태</h2>
<blockquote>
<p>여러개의 프로세스들은 빠르게 번갈아 가면서 실행되는데, 그 과중에서 하나의 프로세스는 여러 상태를 거치며 실행된다. 그리고 운영 체제는 프로세스의 상태를 PCB를 통해 인식하고 관리한다. 프로세스가 가질 수 있는 대표적인 상태는 5가지로 나눌 수 있다.</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/dev_ssj/post/0f34e934-6eb1-4912-adad-7eb052483e2b/image.png" /></p>
<h3 id="1-생성-상태new">1. 생성 상태(new)</h3>
<ul>
<li><strong>프로세스를 생성중인 상태</strong></li>
<li>이제 막 메모리에 적재되어 <strong>PCB를 할당받은 상태</strong></li>
<li>생성 상태를 거쳐 실행할 준비가 완료된 프로세스는 준비상태가 되어 CPU의 할당을 기다린다.</li>
</ul>
<h3 id="2-준비-상태ready">2. 준비 상태(ready)</h3>
<ul>
<li>당장이라도 CPU를 할당받아 실행할 수 있지만, <strong>자신의 차례를 기다리고 있는 상태</strong></li>
<li>차례가 되면 CPU를 할당받아 실행 상태가 된다.</li>
<li>준비 상태인 프로세스가 실행 상태로 전환되는 것을 <strong>디스패치(dispatch)</strong>라고 한다.</li>
</ul>
<h3 id="3-실행-상태running">3. 실행 상태(running)</h3>
<ul>
<li><strong>CPU를 할당받아 실행중인 상태</strong></li>
<li>실행 상태인 프로세스는 할당된 일정 시간 동안만 CPU를 사용할 수 있으며, 할당된 시간을 모두 사용하면 다시 준비상태로 전환된다.</li>
<li>실행 도중 입출력장치를 사용하여 입출력 장치의 작업이 끝날 때까지 기다려야 한다면 대기 상태가 된다.</li>
</ul>
<h3 id="4-대기-상태waitingblocked">4. 대기 상태(waiting/blocked)</h3>
<ul>
<li>프로세스는 실행 도중 입출력장치를 사용하는 경우가 있는데, 입출력 작업은 CPU에 비해 처리 속도가 느리다.</li>
<li>입출력 작업을 요청한 프로세스는 입출력장치가 입출력을 끝날때까지 기다려야 한다.</li>
<li>이렇게 <strong>입출력 작업을 기다리는 상태</strong>를 대기상태라고 한다.</li>
<li>입출력 작업이 완료되면 해당 프로세스는 다시 준비 상태로 CPU 할당을 기다린다.</li>
</ul>
<h3 id="5-종료-상태terminated">5. 종료 상태(terminated)</h3>
<ul>
<li><strong>프로세스가 종료된 상태</strong></li>
<li>프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리한다.</li>
</ul>
<hr />
<h1 id="💡스레드thread">💡스레드(Thread)</h1>
<h2 id="✅프로세스의-한계">✅프로세스의 한계</h2>
<blockquote>
<p>과거에는 프로그램을 실행할 때 하나의 프로세스만을 사용했었다. 하지만 기술이 발전됨에 따라 프로그램이 복잡해지고 다채로워지면서 프로세스 작업 하나만을 사용해서 프로그램을 실행하기에는 한계가 있었고, 멀티 작업을 위해 여러 개의 프로세스를 만들게 되면 그만큼 메모리를 차지하고 CPU에서 할당받는 자원이 중복되게 될 것이다. 스레드는 이러한 프로세스 특성의 한계를 해결하기 위해 탄생하였다.</p>
</blockquote>
<hr />
<h2 id="✅스레드란">✅스레드란?</h2>
<p><img alt="" src="https://velog.velcdn.com/images/dev_ssj/post/1557a993-e1c0-4b38-b5df-0e31e132386a/image.png" />
스레드란 <strong>하나의 프로세스 내에서 동시에 진행되는 작업 갈래, 흐름의 단위</strong>를 말한다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며, 이 스레드들은 <strong>프로세스의 자원을 공유하면서 동시에 실행</strong>될 수 있다.</p>
<hr />
<h2 id="✅스레드의-특징">✅스레드의 특징</h2>
<ul>
<li><strong>메모리 공유</strong> : 스레드는 같은 프로세스 내의 메모리(코드, 데이터, 파일 등)를 공유한다. 즉, 프로세스 내에서 여러 스레드가 같은 데이터에 접근하고 수정할 수 있다. 이로 인해 스레드 간의 통신이 빠르고 효율적이지만, 동기화 문제가 발생할 수 있다.</li>
<li><strong>빠르고 가벼움</strong> : 스레드는 독립적인 자원을 갖지 않기 때문에 프로세스에 비해 생성과 종료가 빠르고 자원을 적게 사용하며 문맥교환이 빠르다. 하지만 메모리를 공유하기 때문에 동시성 문제가 발생할 수 있다.</li>
<li><strong>독립적인 실행 흐름</strong> : 스레드는 각자 독립적인 실행 흐름(스틱)을 가지며, 동시에 여러 작업을 수행할 수 있다. 이를 통해 CPU 활용도를 높일 수 있다.</li>
</ul>
<h3 id="📌context-switching문맥교환">📌<strong>Context Switching(문맥교환)</strong></h3>
<p><img alt="" src="https://velog.velcdn.com/images/dev_ssj/post/5ae0daee-06e8-486b-904b-dc859a8b35bd/image.png" />
CPU가 작업A를 실행하다가 시간이 다 되어 작업B로 CPU 사용을 양보한다고 가정해보도록 하자.
이 상황에서 바로 직전까지 실행된 작업 A는 프로그램 카운터와 각종 레지스터 값, 메모리 정보 등 지금까지의 정보를 <strong>백업</strong>해야 한다. 그래야 다음 작업 차례에서 이전까지 실행했던 내용에 이어 다시 실행을 재개할 수 있으니까! 이러한 <strong>중간 정보를 문맥(Context)</strong>라고 한다.
문맥은 PCB에 저장되며, <strong>실행 순서가 넘어갈 때마다 실행중인 작업의 문맥을 PCB에 백업하고, 새로운 작업을 실행하기 위해 문맥을 PCB에 복구하여 새로운 작업을 실행하는 것을 문맥 교환(Context Switching)</strong>이라고 한다.
문맥 교환 시 자원과 시간이 소모되며, 문맥 교환을 너무 자주 하게 되면 오버헤드가 발생할 수 있다.
스레드 간 전환은 가볍지만, 프로세스 간 전환은 무겁고 비용이 크다.</p>
<hr />
<h2 id="✅스레드의-자원-구조">✅스레드의 자원 구조</h2>
<blockquote>
<p>스레드는 프로세스 내부의 실행 단위이기 때문에, <strong>같은 프로세스 안의 여러 스레드들은 일부 자원을 공유하고, 일부는 개별로 소유</strong>한다. 
스레드는 프로세스 자원을 공유한 채 실행에 필요한 최소한의 정보만으로 실행된다.</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/dev_ssj/post/30fd01a6-609e-4357-bcb5-f37c54a7b257/image.png" /></p>
<p><strong>📍스레드 간 공유 자원</strong></p>
<ul>
<li>코드 영역</li>
<li>힙 영역</li>
<li>전역/정적 변수</li>
</ul>
<p><strong>📍스레드 개별 소유 자원</strong></p>
<ul>
<li><strong>스택 영역(지역변수, 호출기록)</strong></li>
<li>레지스터, PC(프로그램 카운터)</li>
<li>스레드 ID, 상태</li>
</ul>
<hr />
<h2 id="✅스레드의-예시">✅스레드의 예시</h2>
<ul>
<li>크롬 한 프로세스 내에서 각 탭은 별도의 스레드로 동작</li>
<li>웹서버가 여러 요청을 처리할 때 각각의 요청을 별도의 스레드로 처리</li>
</ul>
<hr />
<h2 id="☑️프로세스와-스레드의-차이">☑️프로세스와 스레드의 차이</h2>
<table>
<thead>
<tr>
<th>항목</th>
<th>프로세스</th>
<th>스레드</th>
</tr>
</thead>
<tbody><tr>
<td>기본</td>
<td>독립적인 실행 단위</td>
<td>프로세스 내에서 실행되는 작업 단위</td>
</tr>
<tr>
<td>독립성</td>
<td>각각 독립적</td>
<td>스택만 독립적이고 그 외에는 공유</td>
</tr>
<tr>
<td>자원 할당</td>
<td>CPU, 메모리, 파일 디스크립터 등 자원을 할당 받음</td>
<td>프로세스의 자원을 공유함</td>
</tr>
<tr>
<td>통신 방법</td>
<td>프로세스간 통신(IPC) 필요 -&gt; 비효율적, 복잡</td>
<td>공유 메모리 (효율적, 빠름)</td>
</tr>
<tr>
<td>안정성</td>
<td>하나가 죽어도 다른 프로세스 영향 없음</td>
<td>하나의 스레드 오류 → 전체 프로세스 영향 가능</td>
</tr>
<tr>
<td>생성 및 종료</td>
<td>생성과 종료에 많은 자원과 시간 필요</td>
<td>생성과 종료가 비교적 빠르고 가벼움</td>
</tr>
<tr>
<td>예시</td>
<td>웹 브라우저, 텍스트 편집기 등 독립적인 프로그램</td>
<td>웹 브라우저에서 여러 탭을 처리하는 스레드</td>
</tr>
</tbody></table>
<hr />
<h1 id="💡멀티-프로세스">💡멀티 프로세스</h1>
<h2 id="✅멀티-프로세스란">✅멀티 프로세스란</h2>
<blockquote>
<p>멀티 프로세스란 <strong>하나의 작업을 여러개의 프로세스로 나누어 동시에 실행</strong>하는 방식을 말한다.</p>
</blockquote>
<hr />
<h2 id="✅멀티-프로세스의-특징">✅멀티 프로세스의 특징</h2>
<h3 id="⭕멀티-프로세스의-장점">⭕멀티 프로세스의 장점</h3>
<ul>
<li>메모리 침범 문제를 OS차원에서 해결가능</li>
<li>여러 자식 프로세스 중 하나에 문제가 발생하여도 그 프로세스만 타격 -&gt; <strong>영향이 확산되지 않음</strong></li>
</ul>
<h3 id="❗멀티-프로세스의-단점">❗멀티 프로세스의 단점</h3>
<ul>
<li>Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 됨</li>
<li>프로세스는 각각의 독립된 메모리 영역을 할당받기 때문에 프로세스 사이에서 공유하는 메모리가 없어 Context Switching이 발생하면 캐쉬에 있는 모든 데이터들을 모두 리셋하고 다시 캐쉬 정보를 불러와야 함</li>
<li><strong>프로세스 간의 복잡한 통신 (IPC)</strong> 가 필요함</li>
</ul>
<hr />
<h1 id="💡멀티스레드">💡멀티스레드</h1>
<h2 id="✅멀티-스레드란">✅멀티 스레드란</h2>
<blockquote>
<p>멀티 스레드란 <strong>하나의 프로세스 안에서 여러 스레드가 동시에 실행되며 작업을 분담</strong>하는 방식이다.</p>
</blockquote>
<hr />
<h2 id="✅멀티-스레드의-특징">✅멀티 스레드의 특징</h2>
<h3 id="⭕멀티-스레드의-장점">⭕멀티 스레드의 장점</h3>
<ul>
<li>메모리 공간, 시스템 자원의 효율성 증가</li>
<li>Data, Heap 영역을 이용해 데이터를 주고 받으므로 스레드간 통신이 간단함</li>
<li>context switching시 비용이 적음(교환해야 할게 적으니까) -&gt; <strong>시스템 처리량 향상, 프로그램 응답 시간 단축됨</strong></li>
</ul>
<h3 id="❗멀티-스레드의-단점">❗멀티 스레드의 단점</h3>
<ul>
<li>서로 다른 스레드가 Stack을 제외한 메모리 공간을 공유하기 때문에 <strong>동기화 문제가 발생</strong>할 수 있음</li>
<li>하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받음</li>
<li>주의 깊은 설계가 필요하며 디버깅이 까다로움</li>
</ul>