<h1 id="💡프로세스와-스레드">💡프로세스와 스레드</h1>
<blockquote>
<p>프로세스와 스레드는 운영체제에서 프로그램이 실행될 때 사용되는 기본적인 단위이다.
웹 서버나 애플리케이션에서 동시에 여러 작업을 처리하려면 프로세스와 스레드에 대한 이해가 필요하다. 두 개념은 자원관리, 성능 최적화, 동시성 처리에 직접적인 영향을 주지만 관리와 자원사용 측면에서 차이점이 있다. 이 개념들을 이해하면 시스템에서 작업이 어떻게 실행되고 관리되는지 알 수 있다.</p>
</blockquote>
<hr />
<h1 id="💡프로세스process">💡프로세스(Process)</h1>
<h2 id="✅프로세스란">✅프로세스란?</h2>
<p><strong>실행 중인 프로그램</strong>을 의미하며, 프로그램이 실행되면 운영체제가 <strong>메모리, CPU시간, 자원 등을 할당</strong>하여 독립적으로 실행되는 단위이다. 각각의 프로세스는 <strong>고유의 메모리 공간</strong>(코드, 데이터, 힙, 스택)을 가지고 있다.</p>
<hr />
<h2 id="✅프로세스의-특징">✅프로세스의 특징</h2>
<ul>
<li><p><strong>독립적인 메모리 공간</strong> : 각 프로세스는 운영체제로부터 자신만의 고유한 메모리 공간(스택, 레지스터, 데이터 등)의 자원을 할당 받아 독립적으로 실행된다. 따라서 다른 프로세스와 메모리를 공유하지 않으며, 프로세스 간에는 서로의 데이터에 접근할 수 없다. 다른 프로세스와의 상호작용이 필요할 때는 프로세스 간 통신(IPC, Inter-Process Communication)을 사용해야한다. 프로세스 간 통신은 파이프, 소켓, 공유 메모리 등의 다양한 방법이 있다.</p>
</li>
<li><p><strong>자원관리</strong> : 프로세스는 운영체제로부터 실행에 필요한 시스템 자원(CPU, 메모리, 파일 디스크립터 등)을 할당받는다. 각 프로세스는 고유한 프로세스 ID(PID)를 통해 식별된다.</p>
</li>
<li><p><strong>무거움</strong> : 프로세스는 각각의 독립적인 자원을 가지므로 시스템 자원을 많이 사용하며 생성 및 종료에 시간이 오래걸리며, 문맥 교환 비용이 크다.</p>
</li>
</ul>
<hr />
<h2 id="✅프로세스의-자원-구조">✅프로세스의 자원 구조</h2>
<blockquote>
<p>하나의 프로세스는 <strong>독립적인 메모리 공간</strong>을 가지며, 크게 4가지 메모리 영역으로 나누어져 있다.</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/dev_ssj/post/8c48862e-e969-44f4-bf0c-14eb26485bda/image.png" /></p>
<ul>
<li><strong>코드(Code)</strong> : 프로그램의 실행 코드(기계어)</li>
<li><strong>데이터(Data)</strong> : 전역 변수, 정적 변수 등</li>
<li><strong>힙(Heap)</strong> : 런타임 중 동적으로 생성되는 객체(예시:new 연산자)</li>
<li><strong>스택(Stack)</strong> : 함수 호출, 지역 변수, 매개 변수 등</li>
</ul>
<p>또한, 프로세스는 위 4가지 메모리 영역 외에도 <strong>여러 자원을 독립적으로 소유</strong>한다.</p>
<ul>
<li><strong>파일 디스크립터</strong> : 운영체제가 파일, 소켓, 파이프 등 I/O 자원을 식별하기 위해 부여하는 번호</li>
<li><strong>프로세스ID(PID)</strong> : 운영체제가 각 프로세스를 고유하게 식별하기 위해 부여하는 고유한 번호</li>
<li><strong>PCB(프로세스 제어 블록)</strong> : 운영체제가 프로세스의 상태, 메모리 정보, CPU 레지스터 등을 저장해 프로세스를 관리하는 데 사용하는 데이터 구조</li>
</ul>
<hr />
<h2 id="✅프로세스의-예시">✅프로세스의 예시</h2>
<ul>
<li>크롬을 두 번 실행하면 각각의 창은 독립적인 프로세스</li>
<li>IDE, 메모장, 그림판 등은 각각 별도의 프로세스로 동작함</li>
</ul>
<hr />
<h1 id="💡스레드thread">💡스레드(Thread)</h1>
<h2 id="✅프로세스의-한계">✅프로세스의 한계</h2>
<blockquote>
<p>과거에는 프로그램을 실행할 때 하나의 프로세스만을 사용했었다. 하지만 기술이 발전됨에 따라 프로그램이 복잡해지고 다채로워지면서 프로세스 작업 하나만을 사용해서 프로그램을 실행하기에는 한계가 있었고, 멀티 작업을 위해 여러 개의 프로세스를 만들게 되면 그만큼 메모리를 차지하고 CPU에서 할당받는 자원이 중복되게 될 것이다. 스레드는 이러한 프로세스 특성의 한계를 해결하기 위해 탄생하였다.</p>
</blockquote>
<hr />
<h2 id="✅스레드란">✅스레드란?</h2>
<p><img alt="" src="https://velog.velcdn.com/images/dev_ssj/post/1557a993-e1c0-4b38-b5df-0e31e132386a/image.png" />
스레드란 <strong>하나의 프로세스 내에서 동시에 진행되는 작업 갈래, 흐름의 단위</strong>를 말한다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며, 이 스레드들은 <strong>프로세스의 자원을 공유하면서 동시에 실행</strong>될 수 있다.</p>
<hr />
<h2 id="✅스레드의-특징">✅스레드의 특징</h2>
<ul>
<li><strong>메모리 공유</strong> : 스레드는 같은 프로세스 내의 메모리(코드, 데이터, 파일 등)를 공유한다. 즉, 프로세스 내에서 여러 스레드가 같은 데이터에 접근하고 수정할 수 있다. 이로 인해 스레드 간의 통신이 빠르고 효율적이지만, 동기화 문제가 발생할 수 있다.</li>
<li><strong>빠르고 가벼움</strong> : 스레드는 독립적인 자원을 갖지 않기 때문에 프로세스에 비해 생성과 종료가 빠르고 자원을 적게 사용하며 문맥교환이 빠르다. 하지만 메모리를 공유하기 때문에 동시성 문제가 발생할 수 있다.</li>
<li><strong>독립적인 실행 흐름</strong> : 스레드는 각자 독립적인 실행 흐름(스틱)을 가지며, 동시에 여러 작업을 수행할 수 있다. 이를 통해 CPU 활용도를 높일 수 있다.</li>
</ul>
<hr />
<h2 id="✅스레드의-자원-구조">✅스레드의 자원 구조</h2>
<blockquote>
<p>스레드는 프로세스 내부의 실행 단위이기 때문에, <strong>같은 프로세스 안의 여러 스레드들은 일부 자원을 공유하고, 일부는 개별로 소유</strong>한다.</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/dev_ssj/post/d0290283-20b1-43f1-a7e4-55964b48ef04/image.png" />
<strong>📍스레드 간 공유 자원</strong></p>
<ul>
<li>코드 영역</li>
<li>힙 영역</li>
<li>전역/정적 변수</li>
</ul>
<p><strong>📍스레드 개별 소유 자원</strong></p>
<ul>
<li><strong>스택 영역(지역변수, 호출기록)</strong></li>
<li>레지스터, PC(프로그램 카운터)</li>
<li>스레드 ID, 상태</li>
</ul>
<hr />
<h2 id="✅스레드의-예시">✅스레드의 예시</h2>
<ul>
<li>크롬 한 프로세스 내에서 각 탭은 별도의 스레드로 동작</li>
<li>웹서버가 여러 요청을 처리할 때 각각의 요청을 별도의 스레드로 처리</li>
</ul>
<hr />
<h2 id="☑️프로세스와-스레드의-차이">☑️프로세스와 스레드의 차이</h2>
<table>
<thead>
<tr>
<th>항목</th>
<th>프로세스</th>
<th>스레드</th>
</tr>
</thead>
<tbody><tr>
<td>기본</td>
<td>독립적인 실행 단위</td>
<td>프로세스 내에서 실행되는 작업 단위</td>
</tr>
<tr>
<td>독립성</td>
<td>각각 독립적</td>
<td>스택만 독립적이고 그 외에는 공유</td>
</tr>
<tr>
<td>자원 할당</td>
<td>CPU, 메모리, 파일 디스크립터 등 자원을 할당 받음</td>
<td>프로세스의 자원을 공유함</td>
</tr>
<tr>
<td>통신 방법</td>
<td>프로세스간 통신(IPC) 필요 -&gt; 비효율적, 복잡</td>
<td>공유 메모리 (효율적, 빠름)</td>
</tr>
<tr>
<td>안정성</td>
<td>하나가 죽어도 다른 프로세스 영향 없음</td>
<td>하나의 스레드 오류 → 전체 프로세스 영향 가능</td>
</tr>
<tr>
<td>생성 및 종료</td>
<td>생성과 종료에 많은 자원과 시간 필요</td>
<td>생성과 종료가 비교적 빠르고 가벼움</td>
</tr>
<tr>
<td>예시</td>
<td>웹 브라우저, 텍스트 편집기 등 독립적인 프로그램</td>
<td>웹 브라우저에서 여러 탭을 처리하는 스레드</td>
</tr>
</tbody></table>
<hr />
<h1 id="💡멀티-프로세스">💡멀티 프로세스</h1>
<h2 id="✅멀티-프로세스란">✅멀티 프로세스란</h2>
<blockquote>
<p>멀티 프로세스란 <strong>하나의 작업을 여러개의 프로세스로 나누어 동시에 실행</strong>하는 방식을 말한다.</p>
</blockquote>
<hr />
<h2 id="✅멀티-프로세스의-특징">✅멀티 프로세스의 특징</h2>
<h3 id="⭕멀티-프로세스의-장점">⭕멀티 프로세스의 장점</h3>
<ul>
<li>메모리 침범 문제를 OS차원에서 해결가능</li>
<li>여러 자식 프로세스 중 하나에 문제가 발생하여도 그 프로세스만 타격 -&gt; <strong>영향이 확산되지 않음</strong></li>
</ul>
<h3 id="❗멀티-프로세스의-단점">❗멀티 프로세스의 단점</h3>
<ul>
<li>Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 됨</li>
<li>프로세스는 각각의 독립된 메모리 영역을 할당받기 때문에 프로세스 사이에서 공유하는 메모리가 없어 Context Switching이 발생하면 캐쉬에 있는 모든 데이터들을 모두 리셋하고 다시 캐쉬 정보를 불러와야 함</li>
<li><strong>프로세스 간의 복잡한 통신 (IPC)</strong> 가 필요함</li>
</ul>
<blockquote>
<p>📌<strong>Context Switching(문맥교환)</strong>
CPU가 현재 실행 중인 작업의 상태를 저장하고, 다른 작업의 상태를 불러와 전환하는 과정으로, 이때 자원과 시간이 소모된다.
스레드 간 전환은 가볍지만, 프로세스 간 전환은 무겁고 비용이 크다.</p>
</blockquote>
<hr />
<h1 id="💡멀티스레드">💡멀티스레드</h1>
<h2 id="✅멀티-스레드란">✅멀티 스레드란</h2>
<blockquote>
<p>멀티 스레드란 하<strong>나의 프로세스 안에서 여러 스레드가 동시에 실행되며 작업을 분담</strong>하는 방식이다.</p>
</blockquote>
<hr />
<h2 id="✅멀티-스레드의-특징">✅멀티 스레드의 특징</h2>
<h3 id="⭕멀티-스레드의-장점">⭕멀티 스레드의 장점</h3>
<ul>
<li>메모리 공간, 시스템 자원의 효율성 증가</li>
<li>Data, Heap 영역을 이용해 데이터를 주고 받으므로 스레드간 통신이 간단함</li>
<li>context switching시 비용이 적음(교환해야 할게 적으니까) -&gt; <strong>시스템 처리량 향상, 프로그램 응답 시간 단축됨</strong></li>
</ul>
<h3 id="❗멀티-스레드의-단점">❗멀티 스레드의 단점</h3>
<ul>
<li>서로 다른 스레드가 Stack을 제외한 메모리 공간을 공유하기 때문에 <strong>동기화 문제가 발생</strong>할 수 있음</li>
<li>하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받음</li>
<li>주의 깊은 설계가 필요하며 디버깅이 까다로움</li>
</ul>